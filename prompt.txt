==== models, policies ====
<?php

namespace App\Policies;

use App\Models\User;
use App\Models\Chat;
use Illuminate\Auth\Access\HandlesAuthorization;

class ChatPolicy
{
    use HandlesAuthorization;

    /**
     * Determine if the user can view the chat
     */
    public function view(User $user, Chat $chat): bool
    {
        // Super Admin and State Admin can view all chats
        if ($user->hasAnyRole(['Super Admin', 'State Admin', 'Governor'])) {
            return true;
        }

        // LGA Admin and Enrollment Agent can view chats in their LGA
        if ($user->hasAnyRole(['LGA Admin', 'Enrollment Agent'])) {
            $userLga = $user->administrativeUnit;
            return $userLga && $chat->lga_id === $userLga->id;
        }

        // Farmers can only view their own chats
        if ($user->hasRole('User')) {
            // Check if user has a farmer profile
            if (!$user->farmerProfile) {
                return false;
            }
            
            // Check if this chat belongs to the farmer
            return $chat->farmer_id === $user->farmerProfile->id;
        }

        return false;
    }

    /**
     * Determine if the user can send messages in the chat
     */
    public function sendMessage(User $user, Chat $chat): bool
    {
        // Use same logic as view - if you can view it, you can send messages
        return $this->view($user, $chat);
    }

    /**
     * Determine if the user can assign the chat
     */
    public function assign(User $user, Chat $chat): bool
    {
        // Only admins can assign chats
        if ($user->hasAnyRole(['Super Admin', 'State Admin'])) {
            return true;
        }

        // LGA Admin can assign chats in their LGA
        if ($user->hasRole('LGA Admin')) {
            $userLga = $user->administrativeUnit;
            return $userLga && $chat->lga_id === $userLga->id;
        }

        return false;
    }

    /**
     * Determine if the user can resolve the chat
     */
    public function resolve(User $user, Chat $chat): bool
    {
        // Only admins can resolve chats
        if ($user->hasAnyRole(['Super Admin', 'State Admin'])) {
            return true;
        }

        // LGA Admin can resolve chats in their LGA
        if ($user->hasRole('LGA Admin')) {
            $userLga = $user->administrativeUnit;
            return $userLga && $chat->lga_id === $userLga->id;
        }

        // Assigned admin can resolve
        if ($chat->assigned_admin_id === $user->id) {
            return true;
        }

        return false;
    }

    /**
     * Determine if the user can create chats
     */
    public function create(User $user): bool
    {
        // Only farmers with profiles can create chats
        return $user->hasRole('User') && $user->farmerProfile !== null;
    }
}



<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Chat extends Model
{
    protected $fillable = [
        'farmer_id',
        'assigned_admin_id',
        'lga_id',
        'subject',
        'status',
        'priority',
        'last_message_at',
        'assigned_at',
        'resolved_at',
    ];

    protected $casts = [
        'last_message_at' => 'datetime',
        'assigned_at' => 'datetime',
        'resolved_at' => 'datetime',
    ];

    // Relationships
    // public function farmer(): BelongsTo
    // {
    //     return $this->belongsTo(Farmer::class);
    // }

        /**
     * CRITICAL: Relationship to Farmer model
     */
    public function farmer(): BelongsTo
    {
        return $this->belongsTo(Farmer::class, 'farmer_id');
    }

    public function assignedAdmin(): BelongsTo
    {
        return $this->belongsTo(User::class, 'assigned_admin_id');
    }

    public function lga(): BelongsTo
    {
        return $this->belongsTo(LGA::class);
    }

    public function messages(): HasMany
    {
        return $this->hasMany(Message::class)->orderBy('created_at', 'asc');
    }

    public function latestMessage()
    {
        return $this->hasOne(Message::class)->latestOfMany();
    }

    // Scopes for Role-Based Filtering
    public function scopeForLGA($query, $lgaId)
    {
        return $query->where('lga_id', $lgaId);
    }

    public function scopeForFarmer($query, $farmerId)
    {
        return $query->where('farmer_id', $farmerId);
    }

    public function scopeAssignedTo($query, $adminId)
    {
        return $query->where('assigned_admin_id', $adminId);
    }

    public function scopeActive($query)
    {
        return $query->whereIn('status', ['open', 'in_progress', 'pending_farmer']);
    }

    public function scopeOpen($query)
    {
        return $query->where('status', 'open');
    }

    // Helper Methods
    public function markAsAssigned(User $admin): void
    {
        $this->update([
            'assigned_admin_id' => $admin->id,
            'status' => 'in_progress',
            'assigned_at' => now(),
        ]);
    }

    public function markAsResolved(): void
    {
        $this->update([
            'status' => 'resolved',
            'resolved_at' => now(),
        ]);
    }

    public function getUnreadCountForUser(User $user): int
    {
        return $this->messages()
            ->where('sender_id', '!=', $user->id)
            ->where('is_read', false)
            ->count();
    }
}

class Message extends Model
{
    protected $fillable = [
        'chat_id',
        'sender_id',
        'body',
        'attachments',
        'sender_type',
        'is_read',
        'read_at',
    ];

    protected $casts = [
        'attachments' => 'array',
        'is_read' => 'boolean',
        'read_at' => 'datetime',
    ];

    // Relationships
    public function chat(): BelongsTo
    {
        return $this->belongsTo(Chat::class);
    }

    public function sender(): BelongsTo
    {
        return $this->belongsTo(User::class, 'sender_id');
    }

    // Helper Methods
    public function markAsRead(): void
    {
        if (!$this->is_read) {
            $this->update([
                'is_read' => true,
                'read_at' => now(),
            ]);
        }
    }
}


<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Support\Str;

class Farmer extends Model
{
    use HasFactory, SoftDeletes;

    protected $fillable = [
        'nin',
        'user_id',
        'full_name',
        'phone_primary',
        'phone_secondary',
        'email',
        'gender',
        'marital_status',
        'date_of_birth',
        'lga_id',
        'ward',
        'residential_address',
        'residence_latitude',
        'residence_longitude',
        'educational_level',
        'household_size',
        'primary_occupation',
        'other_occupation',
        'cooperative_id',
        'enrolled_by',
        'approved_by',
        'status',
        'rejection_reason',
        'approved_at',
        'activated_at',
        'initial_password',        
        'password_changed',
        'additional_info',
        'farmer_photo',
    ];

    protected $hidden = [
        'initial_password',
    ];

    protected $casts = [
        'date_of_birth' => 'date',
        'approved_at' => 'datetime',
        'activated_at' => 'datetime',
        'household_size' => 'integer',
        'password_changed' => 'boolean',
        'additional_info' => 'array',
        'residence_latitude' => 'decimal:8',
        'residence_longitude' => 'decimal:8',
    ];

    /**
     * Boot method to handle model events
     */
    protected static function boot()
    {
        parent::boot();

        // Auto-generate initial password when farmer is created
        static::creating(function ($farmer) {
            if (empty($farmer->initial_password)) {
                $farmer->initial_password = Str::random(12); // Secure random password
            }
        });
    }

    // ==================== Relationships ====================

    /**
     * The user account associated with this farmer (after activation)
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * The LGA this farmer belongs to
     */
    public function lga(): BelongsTo
    {
        return $this->belongsTo(LGA::class);
    }

    /**
     * The primary cooperative this farmer belongs to
     */
    public function cooperative(): BelongsTo
    {
        return $this->belongsTo(Cooperative::class);
    }

    /**
     * All cooperatives this farmer is a member of (many-to-many)
     */
    public function cooperatives(): BelongsToMany
    {
        return $this->belongsToMany(Cooperative::class, 'cooperative_farmer')
            ->withPivot([
                'membership_number',
                'joined_date',
                'exit_date',
                'membership_status',
                'position',
                'notes'
            ])
            ->withTimestamps();
    }

    /**
     * The enrollment officer who registered this farmer
     */
    public function enrolledBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'enrolled_by');
    }

    /**
     * The LGA admin who approved this farmer
     */
    public function approvedBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'approved_by');
    }

    /**
     * All farm lands owned by this farmer
     */
    public function farmLands(): HasMany
    {
        return $this->hasMany(FarmLand::class);
    }

    // ==================== Scopes ====================

    /**
     * Scope for farmers in a specific LGA
     */
    public function scopeForLGA($query, $lgaId)
    {
        return $query->where('lga_id', $lgaId);
    }

    /**
     * Scope for farmers enrolled by a specific officer
     */
    public function scopeEnrolledBy($query, $userId)
    {
        return $query->where('enrolled_by', $userId);
    }

    /**
     * Scope for pending review farmers
     */
    public function scopePendingReview($query)
    {
        return $query->where('status', 'pending_lga_review');
    }

    /**
     * Scope for active farmers
     */
    public function scopeActive($query)
    {
        return $query->where('status', 'active');
    }

    /**
     * Scope for farmers needing activation
     */
    public function scopePendingActivation($query)
    {
        return $query->where('status', 'pending_activation');
    }

    // ==================== Helper Methods ====================

    /**
     * Get the farmer's age
     */
    public function getAgeAttribute(): int
    {
        return $this->date_of_birth->age ?? 0;
    }

    /**
     * Get full location string
     */
    public function getFullLocationAttribute(): string
    {
        return "{$this->ward}, {$this->lga->name}";
    }

    /**
     * Check if farmer has completed first login
     */
    public function hasChangedPassword(): bool
    {
        return $this->password_changed;
    }

    /**
     * Check if farmer can be activated
     */
    public function canBeActivated(): bool
    {
        return $this->status === 'pending_activation' && !empty($this->initial_password);
    }

    /**
     * Check if farmer is awaiting LGA approval
     */
    public function isPendingApproval(): bool
    {
        return $this->status === 'pending_lga_review';
    }

    /**
     * Approve farmer enrollment
     */
    public function approve(User $admin): bool
    {
        $this->status = 'pending_activation';
        $this->approved_by = $admin->id;
        $this->approved_at = now();
        return $this->save();
    }

    /**
     * Reject farmer enrollment
     */
    public function reject(User $admin, string $reason): bool
    {
        $this->status = 'rejected';
        $this->approved_by = $admin->id;
        $this->rejection_reason = $reason;
        return $this->save();
    }

    /**
     * Activate farmer account
     */
    public function activate(User $user): bool
    {
        $this->user_id = $user->id;
        $this->status = 'active';
        $this->activated_at = now();
        return $this->save();
    }

    /**
     * Clear initial password after first login
     */
    public function clearInitialPassword(): bool
    {
        $this->initial_password = null;
        $this->password_changed = true;
        return $this->save();
    }

    /**
     * Get total farm land size
     */
    public function getTotalFarmSizeAttribute(): float
    {
        return $this->farmLands()->sum('total_size_hectares') ?? 0;
    }

    /**
     * Get count of farms by type
     */
    public function getFarmCountByType(string $type): int
    {
        return $this->farmLands()->where('farm_type', $type)->count();
    }

    

    /**
     * Bulk status update method
     */
    public static function bulkUpdateStatus(array $farmerIds, string $status, User $admin = null): int
    {
        $updates = ['status' => $status];
        
        if ($admin && in_array($status, ['pending_activation', 'rejected'])) {
            $updates['approved_by'] = $admin->id;
            $updates['approved_at'] = now();
        }
        
        if ($status === 'rejected') {
            $updates['rejection_reason'] = 'Bulk rejection';
        }

        return static::whereIn('id', $farmerIds)->update($updates);
    }

        public function chats()
    {
        return $this->hasMany(Chat::class);
    }
}




<?php


namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;
use Spatie\Permission\Traits\HasRoles; 
use App\Models\Market\MarketplaceListing;
use App\Models\Market\MarketplaceSubscription;
use Illuminate\Contracts\Auth\MustVerifyEmail;






class User extends Authenticatable implements MustVerifyEmail
{
    use HasApiTokens, HasFactory, Notifiable, HasRoles; //  Use Spatie Trait

    protected $fillable = [
        'name',
        'email',
        'phone_number',
        'password',
        'status',
        'administrative_id',
        'administrative_type',
        // Add all other columns here
    ];

    protected $hidden = [
        'password',
        'remember_token',
    ];

    protected $casts = [
        'email_verified_at' => 'datetime',
        'password' => 'hashed',
    ];

    /**
     * Get the owning administrative unit (LGA, Department, or Agency).
     */
    public function administrativeUnit()
    {
        // Define the polymorphic relationship for scoping the user
        return $this->morphTo('administrative');
    }
    
   public function scopeForAdministrativeUnit($query, $type, $id)
    {
        return $query->where('administrative_type', $type)
                    ->where('administrative_id', $id);
    }

    public function scopeForLGA($query, $lgaId)
    {
        return $query->forAdministrativeUnit(LGA::class, $lgaId);
    }

    // ====================Chat  Relationships ====================
    // Add a reverse relationship to the Farmer profile.
    public function farmerProfile()
    {
        // A User can only have one Farmer profile associated with it
        return $this->hasOne(Farmer::class, 'user_id');
    }

    public function chats()
    {
        return $this->hasMany(Chat::class, 'assigned_admin_id');
    }

    // ==================== Marketplace Relationships ====================
    
    /**
     * Get all marketplace listings created by this user.
     */
    public function marketplaceListings()
    {
        return $this->hasMany(MarketplaceListing::class, 'user_id');
    }

    /**
     * Get active marketplace listings.
     */
    public function activeMarketplaceListings()
    {
        return $this->marketplaceListings()
            ->where('status', 'active')
            ->where(function($query) {
                $query->whereNull('expires_at')
                      ->orWhere('expires_at', '>', now());
            });
    }

    /**
     * Get all marketplace subscriptions.
     */
    public function marketplaceSubscriptions()
    {
        return $this->hasMany(MarketplaceSubscription::class, 'user_id');
    }

    /**
     * Get the current active marketplace subscription.
     */
    public function activeMarketplaceSubscription()
    {
        return $this->hasOne(MarketplaceSubscription::class, 'user_id')
            ->where('status', 'paid')
            ->where('end_date', '>', now())
            ->latest('end_date');
    }

    /**
     * Check if user has an active marketplace subscription.
     */
    public function hasActiveMarketplaceSubscription(): bool
    {
        return $this->marketplaceSubscriptions()
            ->where('status', 'paid')
            ->where('end_date', '>', now())
            ->exists();
    }

    /**
     * Get marketplace subscription expiry date.
     */
    public function getMarketplaceSubscriptionExpiryAttribute()
    {
        $subscription = $this->activeMarketplaceSubscription;
        return $subscription?->end_date;
    }

    /**
     * Check if marketplace subscription is expiring soon (within 30 days).
     */
    public function isMarketplaceSubscriptionExpiringSoon(): bool
    {
        $subscription = $this->activeMarketplaceSubscription;
        
        if (!$subscription) {
            return false;
        }

        return $subscription->end_date->diffInDays(now()) <= 30;
    }

    /**
     * Get total marketplace inquiries received.
     */
    public function getTotalMarketplaceInquiriesAttribute()
    {
        return $this->marketplaceListings()->sum('inquiry_count');
    }

    /**
     * Get total marketplace views received.
     */
    public function getTotalMarketplaceViewsAttribute()
    {
        return $this->marketplaceListings()->sum('view_count');
    }


    
}